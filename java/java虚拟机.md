#### `hotSpot`虚拟机对象

* java 堆中对象的分配，布局和访问全过程

##### 对象的创建过程

+ 虚拟机遇到一个`new`指令时，首先将去检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化过，如果没有，必须先执行相应的类加载过程
+ 在类加载检查通过后，虚拟机将为新生对象分配内存，对象所需内存大小在类加载完成后便可完全确定
+ ==如何为对象划分可用空间==
> ​     为对象分配空间等同于把一块确定大小的内存从java堆中划分出来，假设java堆中内存是绝对完整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小同等的距离，这种分配方式成为**指针碰撞**。如果java堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单的进行**指针碰撞**了，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表种找到一块足够大的空间划分为对象实例，并更新列表上的记录，这种分配方式为**空闲列表**。选择哪种分配方式由==java堆是否规整决定==。而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，因此，在使用`serial，pernew`等带有`compact`过程的收集器时，系统采用的分配算法时**指针碰撞**，而使用`cms`这种基于`mark-sweep`算法的收集器时，采用**空闲列表**
+ 如何解决对象并发下的线程安全？（两种方式）

> 1. 对分配内存空间的动作进行同步处理----- 实际上虚拟机采用`cas`配上失败重试的方式保证更新操作的原子性
> 2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在`java`堆中预先分配一小块内存，称为本地线程分配缓冲。那个线程要分配内存，就在那个线程的`tlab`上分配，只有`tlab`用完并分配新的`tlab`时，才需要同步锁定，虚拟机是否使用`tlab`。可以通过`-XX:+/-UseTLAB`参数设定



* 对象的内存分配完成后，需要有对对象进行初始化的过程

>1. 内存分配完成后，虚拟机需要将分配到的内存空间都==初始化==为零值（不包括对象头），如果使用`tlab`，这一工作过程也可以提前至`tlab`分配时进行，这一步操作保证了对象的实例字段在`java`代码中可以不赋初始值就可直接使用，程序就能访问到这些字段的数据类型所对应的零值
>2. 虚拟机对对象进行必要的设置，例如这个对象是那个类的实列，如何找到类的元数据信息，对象的哈希码，对象的`GC`分代年龄等信息。这些信息存放在对象的对象头中，根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象会有不同的设置方式。

* 上述工作完成后，新的对象产生。但从java程序视角来看，对象创建才刚刚开始， --- <init>方法还没有执行，所有字段都为零，所以，一般来说，执行`new`指令后，会接着执行`init`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来





##### 对象的内存布局

